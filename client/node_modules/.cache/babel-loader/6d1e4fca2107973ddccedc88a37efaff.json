{"ast":null,"code":"import { invariant } from './invariant';\nimport { SANCTIONED_UNITS } from './units';\nexport function hasOwnProperty(o, key) {\n  return Object.prototype.hasOwnProperty.call(o, key);\n}\n/**\n * https://tc39.es/ecma262/#sec-toobject\n * @param arg\n */\n\nexport function toObject(arg) {\n  if (arg == null) {\n    throw new TypeError('undefined/null cannot be converted to object');\n  }\n\n  return Object(arg);\n}\n/**\n * https://tc39.es/ecma262/#sec-tostring\n */\n\nexport function toString(o) {\n  // Only symbol is irregular...\n  if (typeof o === 'symbol') {\n    throw TypeError('Cannot convert a Symbol value to a string');\n  }\n\n  return String(o);\n}\n/**\n * https://tc39.es/ecma402/#sec-getoption\n * @param opts\n * @param prop\n * @param type\n * @param values\n * @param fallback\n */\n\nexport function getOption(opts, prop, type, values, fallback) {\n  // const descriptor = Object.getOwnPropertyDescriptor(opts, prop);\n  var value = opts[prop];\n\n  if (value !== undefined) {\n    if (type !== 'boolean' && type !== 'string') {\n      throw new TypeError('invalid type');\n    }\n\n    if (type === 'boolean') {\n      value = Boolean(value);\n    }\n\n    if (type === 'string') {\n      value = toString(value);\n    }\n\n    if (values !== undefined && !values.filter(function (val) {\n      return val == value;\n    }).length) {\n      throw new RangeError(value + \" is not within \" + values.join(', '));\n    }\n\n    return value;\n  }\n\n  return fallback;\n}\n/**\n * https://tc39.es/ecma402/#sec-defaultnumberoption\n * @param val\n * @param min\n * @param max\n * @param fallback\n */\n\nexport function defaultNumberOption(val, min, max, fallback) {\n  if (val !== undefined) {\n    val = Number(val);\n\n    if (isNaN(val) || val < min || val > max) {\n      throw new RangeError(val + \" is outside of range [\" + min + \", \" + max + \"]\");\n    }\n\n    return Math.floor(val);\n  }\n\n  return fallback;\n}\n/**\n * https://tc39.es/ecma402/#sec-getnumberoption\n * @param options\n * @param property\n * @param min\n * @param max\n * @param fallback\n */\n\nexport function getNumberOption(options, property, minimum, maximum, fallback) {\n  var val = options[property];\n  return defaultNumberOption(val, minimum, maximum, fallback);\n}\nexport function setInternalSlot(map, pl, field, value) {\n  if (!map.get(pl)) {\n    map.set(pl, Object.create(null));\n  }\n\n  var slots = map.get(pl);\n  slots[field] = value;\n}\nexport function setMultiInternalSlots(map, pl, props) {\n  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n    var k = _a[_i];\n    setInternalSlot(map, pl, k, props[k]);\n  }\n}\nexport function getInternalSlot(map, pl, field) {\n  return getMultiInternalSlots(map, pl, field)[field];\n}\nexport function getMultiInternalSlots(map, pl) {\n  var fields = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    fields[_i - 2] = arguments[_i];\n  }\n\n  var slots = map.get(pl);\n\n  if (!slots) {\n    throw new TypeError(pl + \" InternalSlot has not been initialized\");\n  }\n\n  return fields.reduce(function (all, f) {\n    all[f] = slots[f];\n    return all;\n  }, Object.create(null));\n}\nexport function isLiteralPart(patternPart) {\n  return patternPart.type === 'literal';\n}\nexport function partitionPattern(pattern) {\n  var result = [];\n  var beginIndex = pattern.indexOf('{');\n  var endIndex = 0;\n  var nextIndex = 0;\n  var length = pattern.length;\n\n  while (beginIndex < pattern.length && beginIndex > -1) {\n    endIndex = pattern.indexOf('}', beginIndex);\n    invariant(endIndex > beginIndex, \"Invalid pattern \" + pattern);\n\n    if (beginIndex > nextIndex) {\n      result.push({\n        type: 'literal',\n        value: pattern.substring(nextIndex, beginIndex)\n      });\n    }\n\n    result.push({\n      type: pattern.substring(beginIndex + 1, endIndex),\n      value: undefined\n    });\n    nextIndex = endIndex + 1;\n    beginIndex = pattern.indexOf('{', nextIndex);\n  }\n\n  if (nextIndex < length) {\n    result.push({\n      type: 'literal',\n      value: pattern.substring(nextIndex, length)\n    });\n  }\n\n  return result;\n}\n/**\n * https://tc39.es/ecma402/#sec-setnfdigitoptions\n */\n\nexport function setNumberFormatDigitOptions(internalSlots, opts, mnfdDefault, mxfdDefault, notation) {\n  var mnid = getNumberOption(opts, 'minimumIntegerDigits', 1, 21, 1);\n  var mnfd = opts.minimumFractionDigits;\n  var mxfd = opts.maximumFractionDigits;\n  var mnsd = opts.minimumSignificantDigits;\n  var mxsd = opts.maximumSignificantDigits;\n  internalSlots.minimumIntegerDigits = mnid;\n\n  if (mnsd !== undefined || mxsd !== undefined) {\n    internalSlots.roundingType = 'significantDigits';\n    mnsd = defaultNumberOption(mnsd, 1, 21, 1);\n    mxsd = defaultNumberOption(mxsd, mnsd, 21, 21);\n    internalSlots.minimumSignificantDigits = mnsd;\n    internalSlots.maximumSignificantDigits = mxsd;\n  } else if (mnfd !== undefined || mxfd !== undefined) {\n    internalSlots.roundingType = 'fractionDigits';\n    mnfd = defaultNumberOption(mnfd, 0, 20, mnfdDefault);\n    var mxfdActualDefault = Math.max(mnfd, mxfdDefault);\n    mxfd = defaultNumberOption(mxfd, mnfd, 20, mxfdActualDefault);\n    internalSlots.minimumFractionDigits = mnfd;\n    internalSlots.maximumFractionDigits = mxfd;\n  } else if (notation === 'compact') {\n    internalSlots.roundingType = 'compactRounding';\n  } else {\n    internalSlots.roundingType = 'fractionDigits';\n    internalSlots.minimumFractionDigits = mnfdDefault;\n    internalSlots.maximumFractionDigits = mxfdDefault;\n  }\n}\nexport function objectIs(x, y) {\n  if (Object.is) {\n    return Object.is(x, y);\n  } // SameValue algorithm\n\n\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  } // Step 6.a: NaN == NaN\n\n\n  return x !== x && y !== y;\n}\nvar NOT_A_Z_REGEX = /[^A-Z]/;\n/**\n * This follows https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping\n * @param str string to convert\n */\n\nfunction toUpperCase(str) {\n  return str.replace(/([a-z])/g, function (_, c) {\n    return c.toUpperCase();\n  });\n}\n/**\n * https://tc39.es/ecma402/#sec-iswellformedcurrencycode\n */\n\n\nexport function isWellFormedCurrencyCode(currency) {\n  currency = toUpperCase(currency);\n\n  if (currency.length !== 3) {\n    return false;\n  }\n\n  if (NOT_A_Z_REGEX.test(currency)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * https://tc39.es/ecma402/#sec-formatnumberstring\n * TODO: dedup with intl-pluralrules\n */\n\nexport function formatNumericToString(internalSlots, x) {\n  var isNegative = x < 0 || objectIs(x, -0);\n\n  if (isNegative) {\n    x = -x;\n  }\n\n  var result;\n  var rourndingType = internalSlots.roundingType;\n\n  switch (rourndingType) {\n    case 'significantDigits':\n      result = toRawPrecision(x, internalSlots.minimumSignificantDigits, internalSlots.maximumSignificantDigits);\n      break;\n\n    case 'fractionDigits':\n      result = toRawFixed(x, internalSlots.minimumFractionDigits, internalSlots.maximumFractionDigits);\n      break;\n\n    default:\n      result = toRawPrecision(x, 1, 2);\n\n      if (result.integerDigitsCount > 1) {\n        result = toRawFixed(x, 0, 0);\n      }\n\n      break;\n  }\n\n  x = result.roundedNumber;\n  var string = result.formattedString;\n  var int = result.integerDigitsCount;\n  var minInteger = internalSlots.minimumIntegerDigits;\n\n  if (int < minInteger) {\n    var forwardZeros = repeat('0', minInteger - int);\n    string = forwardZeros + string;\n  }\n\n  if (isNegative) {\n    x = -x;\n  }\n\n  return {\n    roundedNumber: x,\n    formattedString: string\n  };\n}\n/**\n * TODO: dedup with intl-pluralrules and support BigInt\n * https://tc39.es/ecma402/#sec-torawfixed\n * @param x a finite non-negative Number or BigInt\n * @param minFraction and integer between 0 and 20\n * @param maxFraction and integer between 0 and 20\n */\n\nexport function toRawFixed(x, minFraction, maxFraction) {\n  var f = maxFraction;\n  var n = Math.round(x * Math.pow(10, f));\n  var xFinal = n / Math.pow(10, f); // n is a positive integer, but it is possible to be greater than 1e21.\n  // In such case we will go the slow path.\n  // See also: https://tc39.es/ecma262/#sec-numeric-types-number-tostring\n\n  var m;\n\n  if (n < 1e21) {\n    m = n.toString();\n  } else {\n    m = n.toString();\n\n    var _a = m.split('e'),\n        mantissa = _a[0],\n        exponent = _a[1];\n\n    m = mantissa.replace('.', '');\n    m = m + repeat('0', Math.max(+exponent - m.length + 1, 0));\n  }\n\n  var int;\n\n  if (f !== 0) {\n    var k = m.length;\n\n    if (k <= f) {\n      var z = repeat('0', f + 1 - k);\n      m = z + m;\n      k = f + 1;\n    }\n\n    var a = m.slice(0, k - f);\n    var b = m.slice(k - f);\n    m = a + \".\" + b;\n    int = a.length;\n  } else {\n    int = m.length;\n  }\n\n  var cut = maxFraction - minFraction;\n\n  while (cut > 0 && m[m.length - 1] === '0') {\n    m = m.slice(0, -1);\n    cut--;\n  }\n\n  if (m[m.length - 1] === '.') {\n    m = m.slice(0, -1);\n  }\n\n  return {\n    formattedString: m,\n    roundedNumber: xFinal,\n    integerDigitsCount: int\n  };\n} // https://tc39.es/ecma402/#sec-torawprecision\n\nexport function toRawPrecision(x, minPrecision, maxPrecision) {\n  var p = maxPrecision;\n  var m;\n  var e;\n  var xFinal;\n\n  if (x === 0) {\n    m = repeat('0', p);\n    e = 0;\n    xFinal = 0;\n  } else {\n    var xToString = x.toString(); // If xToString is formatted as scientific notation, the number is either very small or very\n    // large. If the precision of the formatted string is lower that requested max precision, we\n    // should still infer them from the formatted string, otherwise the formatted result might have\n    // precision loss (e.g. 1e41 will not have 0 in every trailing digits).\n\n    var xToStringExponentIndex = xToString.indexOf('e');\n\n    var _a = xToString.split('e'),\n        xToStringMantissa = _a[0],\n        xToStringExponent = _a[1];\n\n    var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');\n\n    if (xToStringExponentIndex >= 0 && xToStringMantissaWithoutDecimalPoint.length <= p) {\n      e = +xToStringExponent;\n      m = xToStringMantissaWithoutDecimalPoint + repeat('0', p - xToStringMantissaWithoutDecimalPoint.length);\n      xFinal = x;\n    } else {\n      e = getMagnitude(x);\n      var decimalPlaceOffset = e - p + 1; // n is the integer containing the required precision digits. To derive the formatted string,\n      // we will adjust its decimal place in the logic below.\n\n      var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset)); // The rounding caused the change of magnitude, so we should increment `e` by 1.\n\n      if (adjustDecimalPlace(n, p - 1) >= 10) {\n        e = e + 1; // Divide n by 10 to swallow one precision.\n\n        n = Math.floor(n / 10);\n      }\n\n      m = n.toString(); // Equivalent of n * 10 ** (e - p + 1)\n\n      xFinal = adjustDecimalPlace(n, p - 1 - e);\n    }\n  }\n\n  var int;\n\n  if (e >= p - 1) {\n    m = m + repeat('0', e - p + 1);\n    int = e + 1;\n  } else if (e >= 0) {\n    m = m.slice(0, e + 1) + \".\" + m.slice(e + 1);\n    int = e + 1;\n  } else {\n    m = \"0.\" + repeat('0', -e - 1) + m;\n    int = 1;\n  }\n\n  if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {\n    var cut = maxPrecision - minPrecision;\n\n    while (cut > 0 && m[m.length - 1] === '0') {\n      m = m.slice(0, -1);\n      cut--;\n    }\n\n    if (m[m.length - 1] === '.') {\n      m = m.slice(0, -1);\n    }\n  }\n\n  return {\n    formattedString: m,\n    roundedNumber: xFinal,\n    integerDigitsCount: int\n  }; // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.\n\n  function adjustDecimalPlace(x, magnitude) {\n    return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);\n  }\n}\nexport function repeat(s, times) {\n  if (typeof s.repeat === 'function') {\n    return s.repeat(times);\n  }\n\n  var arr = new Array(times);\n\n  for (var i = 0; i < arr.length; i++) {\n    arr[i] = s;\n  }\n\n  return arr.join('');\n}\n/**\n * Cannot do Math.log(x) / Math.log(10) bc if IEEE floating point issue\n * @param x number\n */\n\nexport function getMagnitude(x) {\n  // Cannot count string length via Number.toString because it may use scientific notation\n  // for very small or very large numbers.\n  return Math.floor(Math.log(x) * Math.LOG10E);\n}\n/**\n * This follows https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping\n * @param str string to convert\n */\n\nfunction toLowerCase(str) {\n  return str.replace(/([A-Z])/g, function (_, c) {\n    return c.toLowerCase();\n  });\n}\n\nvar SHORTENED_SACTION_UNITS = SANCTIONED_UNITS.map(function (unit) {\n  return unit.replace(/^(.*?)-/, '');\n});\n/**\n * https://tc39.es/ecma402/#sec-iswellformedunitidentifier\n * @param unit\n */\n\nexport function isWellFormedUnitIdentifier(unit) {\n  unit = toLowerCase(unit);\n\n  if (SHORTENED_SACTION_UNITS.indexOf(unit) > -1) {\n    return true;\n  }\n\n  var units = unit.split('-per-');\n\n  if (units.length !== 2) {\n    return false;\n  }\n\n  if (SHORTENED_SACTION_UNITS.indexOf(units[0]) < 0 || SHORTENED_SACTION_UNITS.indexOf(units[1]) < 0) {\n    return false;\n  }\n\n  return true;\n}\n/*\n  17 ECMAScript Standard Built-in Objects:\n    Every built-in Function object, including constructors, that is not\n    identified as an anonymous function has a name property whose value\n    is a String.\n\n    Unless otherwise specified, the name property of a built-in Function\n    object, if it exists, has the attributes { [[Writable]]: false,\n    [[Enumerable]]: false, [[Configurable]]: true }.\n*/\n\nexport function defineProperty(target, name, _a) {\n  var value = _a.value;\n  Object.defineProperty(target, name, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: value\n  });\n}","map":null,"metadata":{},"sourceType":"module"}