{"ast":null,"code":"module.exports = function (_) {\n  // Helpers\n  // -------\n  // No reason to create regex more than once\n  var REGEX = {\n    boundary: /(\\b.)/g,\n    bracket: /(?:([^\\[]+))|(?:\\[(.*?)\\])/g,\n    capitalLetters: /([A-Z])/g,\n    dot: /\\./g,\n    htmlTags: /<\\/?[^<>]*>/gi,\n    lowerThenUpper: /([a-z])([A-Z])/g,\n    nonCamelCase: /[-_\\s](\\w)/g,\n    plus: /\\+/g,\n    regex: /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g,\n    space: / /g,\n    underscore: /_/g,\n    upperThenLower: /\\b([A-Z]+)([A-Z])([a-z])/g\n  };\n\n  var urlDecode = function urlDecode(s) {\n    return decodeURIComponent(s.replace(REGEX.plus, '%20'));\n  };\n\n  var buildParams = function buildParams(prefix, val, top) {\n    if (_.isUndefined(top)) top = true;\n\n    if (_.isArray(val)) {\n      return _.map(val, function (value, key) {\n        return buildParams(top ? key : prefix + '[]', value, false);\n      }).join('&');\n    } else if (_.isObject(val)) {\n      return _.map(val, function (value, key) {\n        return buildParams(top ? key : prefix + '[' + key + ']', value, false);\n      }).join('&');\n    } else {\n      return encodeURIComponent(prefix) + '=' + encodeURIComponent(val);\n    }\n  }; // Mixing in the string utils\n  // ----------------------------\n\n\n  _.mixin({\n    // Explodes a string into an array of chars\n    explode: function explode(s) {\n      return s.split('');\n    },\n    // Parses a query string into a hash\n    fromQuery: function fromQuery(str) {\n      var parameters = str.split('&'),\n          obj = {},\n          parameter,\n          key,\n          match,\n          lastKey,\n          subKey,\n          depth; // Iterate over key/value pairs\n\n      _.each(parameters, function (parameter) {\n        parameter = parameter.split('=');\n        key = urlDecode(parameter[0]);\n        lastKey = key;\n        depth = obj; // Reset so we don't have issues when matching the same string\n\n        REGEX.bracket.lastIndex = 0; // Attempt to extract nested values\n\n        while ((match = REGEX.bracket.exec(key)) !== null) {\n          if (!_.isUndefined(match[1])) {\n            // If we're at the top nested level, no new object needed\n            subKey = match[1];\n          } else {\n            // If we're at a lower nested level, we need to step down, and make\n            // sure that there is an object to place the value into\n            subKey = match[2];\n            depth[lastKey] = depth[lastKey] || (subKey ? {} : []);\n            depth = depth[lastKey];\n          } // Save the correct key as a hash or an array\n\n\n          lastKey = subKey || _.size(depth);\n        } // Assign value to nested object\n\n\n        depth[lastKey] = urlDecode(parameter[1]);\n      });\n\n      return obj;\n    },\n    // Implodes and array of chars into a string\n    implode: function implode(a) {\n      return a.join('');\n    },\n    // Converts camel case to dashed (opposite of _.camelCase)\n    toDash: function toDash(string) {\n      string = string.replace(REGEX.capitalLetters, function ($1) {\n        return \"-\" + $1.toLowerCase();\n      }); // remove first dash\n\n      return string.charAt(0) == '-' ? string.substr(1) : string;\n    },\n    // Creates a query string from a hash\n    toQuery: function toQuery(obj) {\n      return buildParams('', obj);\n    },\n    // Reports whether a string contains a search string.\n    strContains: function strContains(str, search) {\n      if (typeof str != 'string') throw new TypeError('First argument to strContains must be a string');\n      return str.indexOf(search) != -1;\n    },\n    // Upper case first letter in every word.\n    titleCase: function capitalize(string) {\n      return string.replace(REGEX.boundary, function ($1) {\n        return $1.toUpperCase();\n      });\n    },\n    // Slugify a string. Makes lowercase, and converts dots and spaces to dashes.\n    slugify: function slugify(urlString) {\n      return urlString.replace(REGEX.lowerThenUpper, '$1-$2').replace(REGEX.space, '-').replace(REGEX.dot, '-').toLowerCase();\n    },\n    // Humanize a slug by adding spaces in place of underscores and between words\n    humanize: function humanize(slugish) {\n      return _.capitalize(slugish // Replace _ with a space\n      .replace(REGEX.underscore, ' ') // insert a space between lower & upper\n      .replace(REGEX.lowerThenUpper, '$1 $2') // space before last upper in a sequence followed by lower\n      .replace(REGEX.upperThenLower, '$1 $2$3'));\n    },\n    // Strip HTML-ish tags from string\n    stripTags: function stripTags(suspectString) {\n      var str = suspectString.replace(REGEX.htmlTags, '');\n      return str;\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}