{"ast":null,"code":"module.exports = function (_) {\n  // Helpers\n  // -------\n  var HASNTBEENRUN = {};\n\n  function unary(fun) {\n    return function (first) {\n      return fun.call(this, first);\n    };\n  }\n\n  function binary(fun) {\n    return function (first, second) {\n      return fun.call(this, first, second);\n    };\n  } // Mixing in the iterator functions\n  // --------------------------------\n\n\n  function foldl(iter, binaryFn, seed) {\n    var state, element;\n\n    if (seed !== void 0) {\n      state = seed;\n    } else {\n      state = iter();\n    }\n\n    element = iter();\n\n    while (element != null) {\n      state = binaryFn.call(element, state, element);\n      element = iter();\n    }\n\n    return state;\n  }\n\n  function unfold(seed, unaryFn) {\n    var state = HASNTBEENRUN;\n    return function () {\n      if (state === HASNTBEENRUN) {\n        state = seed;\n      } else if (state != null) {\n        state = unaryFn.call(state, state);\n      }\n\n      return state;\n    };\n  } // note that the unfoldWithReturn behaves differently than\n  // unfold with respect to the first value returned\n\n\n  function unfoldWithReturn(seed, unaryFn) {\n    var state = seed,\n        pair,\n        value;\n    return function () {\n      if (state != null) {\n        pair = unaryFn.call(state, state);\n        value = pair[1];\n        state = value != null ? pair[0] : void 0;\n        return value;\n      } else return void 0;\n    };\n  }\n\n  function accumulate(iter, binaryFn, initial) {\n    var state = initial;\n    return function () {\n      var element = iter();\n\n      if (element == null) {\n        return element;\n      } else {\n        if (state === void 0) {\n          state = element;\n        } else {\n          state = binaryFn.call(element, state, element);\n        }\n\n        return state;\n      }\n    };\n  }\n\n  function accumulateWithReturn(iter, binaryFn, initial) {\n    var state = initial,\n        stateAndReturnValue,\n        element;\n    return function () {\n      element = iter();\n\n      if (element == null) {\n        return element;\n      } else {\n        if (state === void 0) {\n          state = element;\n          return state;\n        } else {\n          stateAndReturnValue = binaryFn.call(element, state, element);\n          state = stateAndReturnValue[0];\n          return stateAndReturnValue[1];\n        }\n      }\n    };\n  }\n\n  function map(iter, unaryFn) {\n    return function () {\n      var element;\n      element = iter();\n\n      if (element != null) {\n        return unaryFn.call(element, element);\n      } else {\n        return void 0;\n      }\n    };\n  }\n\n  function mapcat(iter, unaryFn) {\n    var lastIter = null;\n    return function () {\n      var element;\n      var gen;\n\n      if (lastIter == null) {\n        gen = iter();\n\n        if (gen == null) {\n          lastIter = null;\n          return void 0;\n        }\n\n        lastIter = unaryFn.call(gen, gen);\n      }\n\n      while (element == null) {\n        element = lastIter();\n\n        if (element == null) {\n          gen = iter();\n\n          if (gen == null) {\n            lastIter = null;\n            return void 0;\n          } else {\n            lastIter = unaryFn.call(gen, gen);\n          }\n        }\n      }\n\n      return element;\n    };\n  }\n\n  function select(iter, unaryPredicateFn) {\n    return function () {\n      var element;\n      element = iter();\n\n      while (element != null) {\n        if (unaryPredicateFn.call(element, element)) {\n          return element;\n        }\n\n        element = iter();\n      }\n\n      return void 0;\n    };\n  }\n\n  function reject(iter, unaryPredicateFn) {\n    return select(iter, function (something) {\n      return !unaryPredicateFn(something);\n    });\n  }\n\n  function find(iter, unaryPredicateFn) {\n    return select(iter, unaryPredicateFn)();\n  }\n\n  function slice(iter, numberToDrop, numberToTake) {\n    var count = 0;\n\n    while (numberToDrop-- > 0) {\n      iter();\n    }\n\n    if (numberToTake != null) {\n      return function () {\n        if (++count <= numberToTake) {\n          return iter();\n        } else {\n          return void 0;\n        }\n      };\n    } else return iter;\n  }\n\n  function drop(iter, numberToDrop) {\n    return slice(iter, numberToDrop == null ? 1 : numberToDrop);\n  }\n\n  function take(iter, numberToTake) {\n    return slice(iter, 0, numberToTake == null ? 1 : numberToTake);\n  }\n\n  function List(array) {\n    var index = 0;\n    return function () {\n      return array[index++];\n    };\n  }\n\n  function Tree(array) {\n    var index, _myself, state;\n\n    index = 0;\n    state = [];\n\n    _myself = function myself() {\n      var element, tempState;\n      element = array[index++];\n\n      if (element instanceof Array) {\n        state.push({\n          array: array,\n          index: index\n        });\n        array = element;\n        index = 0;\n        return _myself();\n      } else if (element === void 0) {\n        if (state.length > 0) {\n          tempState = state.pop();\n          array = tempState.array;\n          index = tempState.index;\n          return _myself();\n        } else {\n          return void 0;\n        }\n      } else {\n        return element;\n      }\n    };\n\n    return _myself;\n  }\n\n  function K(value) {\n    return function () {\n      return value;\n    };\n  }\n\n  function upRange(from, to, by) {\n    return function () {\n      var was;\n\n      if (from > to) {\n        return void 0;\n      } else {\n        was = from;\n        from = from + by;\n        return was;\n      }\n    };\n  }\n\n  function downRange(from, to, by) {\n    return function () {\n      var was;\n\n      if (from < to) {\n        return void 0;\n      } else {\n        was = from;\n        from = from - by;\n        return was;\n      }\n    };\n  }\n\n  function range(from, to, by) {\n    if (from == null) {\n      return upRange(1, Infinity, 1);\n    } else if (to == null) {\n      return upRange(from, Infinity, 1);\n    } else if (by == null) {\n      if (from <= to) {\n        return upRange(from, to, 1);\n      } else return downRange(from, to, 1);\n    } else if (by > 0) {\n      return upRange(from, to, by);\n    } else if (by < 0) {\n      return downRange(from, to, Math.abs(by));\n    } else return k(from);\n  }\n\n  var numbers = unary(range);\n  _.iterators = {\n    accumulate: accumulate,\n    accumulateWithReturn: accumulateWithReturn,\n    foldl: foldl,\n    reduce: foldl,\n    unfold: unfold,\n    unfoldWithReturn: unfoldWithReturn,\n    map: map,\n    mapcat: mapcat,\n    select: select,\n    reject: reject,\n    filter: select,\n    find: find,\n    slice: slice,\n    drop: drop,\n    take: take,\n    List: List,\n    Tree: Tree,\n    constant: K,\n    K: K,\n    numbers: numbers,\n    range: range\n  };\n};","map":null,"metadata":{},"sourceType":"script"}