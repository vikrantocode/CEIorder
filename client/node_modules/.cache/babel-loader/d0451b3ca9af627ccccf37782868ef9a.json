{"ast":null,"code":"module.exports = function (_) {\n  // Helpers\n  // -------\n  // Create quick reference variables for speed access to core prototypes.\n  var slice = Array.prototype.slice,\n      concat = Array.prototype.concat;\n\n  var existy = function existy(x) {\n    return x != null;\n  };\n\n  var truthy = function truthy(x) {\n    return x !== false && existy(x);\n  };\n\n  var isAssociative = function isAssociative(x) {\n    return _.isArray(x) || _.isObject(x);\n  };\n\n  var curry2 = function curry2(fun) {\n    return function (last) {\n      return function (first) {\n        return fun(first, last);\n      };\n    };\n  }; // Mixing in the object builders\n  // ----------------------------\n\n\n  _.mixin({\n    // Takes an object and another object of strings to strings where the second\n    // object describes the key renaming to occur in the first object.\n    renameKeys: function renameKeys(obj, kobj) {\n      return _.reduce(kobj, function (o, nu, old) {\n        if (existy(obj[old])) {\n          o[nu] = obj[old];\n          return o;\n        } else return o;\n      }, _.omit.apply(null, concat.call([obj], _.keys(kobj))));\n    },\n    // Snapshots an object deeply. Based on the version by\n    // [Keith Devens](http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone)\n    // until we can find a more efficient and robust way to do it.\n    snapshot: function snapshot(obj) {\n      if (obj == null || typeof obj != 'object') {\n        return obj;\n      }\n\n      var temp = new obj.constructor();\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          temp[key] = _.snapshot(obj[key]);\n        }\n      }\n\n      return temp;\n    },\n    // Updates the value at any depth in a nested object based on the\n    // path described by the keys given.  The function provided is supplied\n    // the current value and is expected to return a value for use as the\n    // new value.  If no keys are provided, then the object itself is presented\n    // to the given function.\n    updatePath: function updatePath(obj, fun, ks, defaultValue) {\n      if (!isAssociative(obj)) throw new TypeError(\"Attempted to update a non-associative object.\");\n      if (!existy(ks)) return fun(obj);\n\n      var deepness = _.isArray(ks);\n\n      var keys = deepness ? ks : [ks];\n      var ret = deepness ? _.snapshot(obj) : _.clone(obj);\n\n      var lastKey = _.last(keys);\n\n      var target = ret;\n\n      _.each(_.initial(keys), function (key) {\n        if (defaultValue && !_.has(target, key)) {\n          target[key] = _.clone(defaultValue);\n        }\n\n        target = target[key];\n      });\n\n      target[lastKey] = fun(target[lastKey]);\n      return ret;\n    },\n    // Sets the value at any depth in a nested object based on the\n    // path described by the keys given.\n    setPath: function setPath(obj, value, ks, defaultValue) {\n      if (!existy(ks)) throw new TypeError(\"Attempted to set a property at a null path.\");\n      return _.updatePath(obj, function () {\n        return value;\n      }, ks, defaultValue);\n    },\n    // Returns an object where each element of an array is keyed to\n    // the number of times that it occurred in said array.\n    frequencies: curry2(_.countBy)(_.identity)\n  });\n};","map":null,"metadata":{},"sourceType":"script"}