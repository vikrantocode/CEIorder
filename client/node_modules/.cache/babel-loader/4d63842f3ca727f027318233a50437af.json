{"ast":null,"code":"module.exports = function (_) {\n  // Helpers\n  // -------\n  var existy = function existy(x) {\n    return x != null;\n  };\n\n  var truthy = function truthy(x) {\n    return x !== false && existy(x);\n  };\n\n  var __reverse = [].reverse;\n  var __slice = [].slice;\n  var __map = [].map;\n\n  var curry2 = function curry2(fun) {\n    return function curried(first, optionalLast) {\n      if (arguments.length === 1) {\n        return function (last) {\n          return fun(first, last);\n        };\n      } else return fun(first, optionalLast);\n    };\n  }; // n.b. depends on lodash.function.arity.js\n  // Takes a target function and a mapping function. Returns a function\n  // that applies the mapper to its arguments before evaluating the body.\n\n\n  function baseMapArgs(fun, mapFun) {\n    return _.arity(fun.length, function () {\n      return fun.apply(this, __map.call(arguments, mapFun));\n    });\n  } // Mixing in the combinator functions\n  // ----------------------------------\n\n\n  _.mixin({\n    // Provide \"always\" alias for backwards compatibility\n    always: _.constant,\n    // Takes some number of functions, either as an array or variadically\n    // and returns a function that takes some value as its first argument\n    // and runs it through a pipeline of the original functions given.\n    pipeline: function pipeline()\n    /*, funs */\n    {\n      var funs = _.isArray(arguments[0]) ? arguments[0] : arguments;\n      return function (seed) {\n        return _.reduce(funs, function (l, r) {\n          return r(l);\n        }, seed);\n      };\n    },\n    composeRight: _.pipeline,\n    // Composes a bunch of predicates into a single predicate that\n    // checks all elements of an array for conformance to all of the\n    // original predicates.\n    conjoin: function conjoin()\n    /* preds */\n    {\n      var preds = arguments;\n      return function (array) {\n        return _.every(array, function (e) {\n          return _.every(preds, function (p) {\n            return p(e);\n          });\n        });\n      };\n    },\n    // Composes a bunch of predicates into a single predicate that\n    // checks all elements of an array for conformance to any of the\n    // original predicates.\n    disjoin: function disjoin()\n    /* preds */\n    {\n      var preds = arguments;\n      return function (array) {\n        return _.some(array, function (e) {\n          return _.some(preds, function (p) {\n            return p(e);\n          });\n        });\n      };\n    },\n    // Takes a predicate-like and returns a comparator (-1,0,1).\n    comparator: function comparator(fun) {\n      return function (x, y) {\n        if (truthy(fun(x, y))) return -1;else if (truthy(fun(y, x))) return 1;else return 0;\n      };\n    },\n    // Returns a function that reverses the sense of a given predicate-like.\n    complement: function complement(pred) {\n      return function () {\n        return !pred.apply(this, arguments);\n      };\n    },\n    // Takes a function expecting varargs and\n    // returns a function that takes an array and\n    // uses its elements as the args to  the original\n    // function\n    splat: function splat(fun) {\n      return function (array) {\n        return fun.apply(this, array);\n      };\n    },\n    // Takes a function expecting an array and returns\n    // a function that takes varargs and wraps all\n    // in an array that is passed to the original function.\n    unsplat: function unsplat(fun) {\n      var funLength = fun.length;\n\n      if (funLength < 1) {\n        return fun;\n      } else if (funLength === 1) {\n        return function () {\n          return fun.call(this, __slice.call(arguments, 0));\n        };\n      } else {\n        return function () {\n          var numberOfArgs = arguments.length,\n              namedArgs = __slice.call(arguments, 0, funLength - 1),\n              numberOfMissingNamedArgs = Math.max(funLength - numberOfArgs - 1, 0),\n              argPadding = new Array(numberOfMissingNamedArgs),\n              variadicArgs = __slice.call(arguments, fun.length - 1);\n\n          return fun.apply(this, namedArgs.concat(argPadding).concat([variadicArgs]));\n        };\n      }\n    },\n    // Same as unsplat, but the rest of the arguments are collected in the\n    // first parameter, e.g. unsplatl( function (args, callback) { ... ]})\n    unsplatl: function unsplatl(fun) {\n      var funLength = fun.length;\n\n      if (funLength < 1) {\n        return fun;\n      } else if (funLength === 1) {\n        return function () {\n          return fun.call(this, __slice.call(arguments, 0));\n        };\n      } else {\n        return function () {\n          var numberOfArgs = arguments.length,\n              namedArgs = __slice.call(arguments, Math.max(numberOfArgs - funLength + 1, 0)),\n              variadicArgs = __slice.call(arguments, 0, Math.max(numberOfArgs - funLength + 1, 0));\n\n          return fun.apply(this, [variadicArgs].concat(namedArgs));\n        };\n      }\n    },\n    // map the arguments of a function\n    mapArgs: curry2(baseMapArgs),\n    // Returns a function that returns an array of the calls to each\n    // given function for some arguments.\n    juxt: function juxt()\n    /* funs */\n    {\n      var funs = arguments;\n      return function ()\n      /* args */\n      {\n        var args = arguments;\n        return _.map(funs, function (f) {\n          return f.apply(this, args);\n        }, this);\n      };\n    },\n    // Returns a function that protects a given function from receiving\n    // non-existy values.  Each subsequent value provided to `fnull` acts\n    // as the default to the original function should a call receive non-existy\n    // values in the defaulted arg slots.\n    fnull: function fnull(fun\n    /*, defaults */\n    ) {\n      var defaults = _.rest(arguments);\n\n      return function ()\n      /*args*/\n      {\n        var args = _.toArray(arguments);\n\n        var sz = _.size(defaults);\n\n        for (var i = 0; i < sz; i++) {\n          if (!existy(args[i])) args[i] = defaults[i];\n        }\n\n        return fun.apply(this, args);\n      };\n    },\n    // Flips the first two args of a function\n    flip2: function flip2(fun) {\n      return function ()\n      /* args */\n      {\n        var flipped = __slice.call(arguments);\n\n        flipped[0] = arguments[1];\n        flipped[1] = arguments[0];\n        return fun.apply(this, flipped);\n      };\n    },\n    // Flips an arbitrary number of args of a function\n    flip: function flip(fun) {\n      return function ()\n      /* args */\n      {\n        var reversed = __reverse.call(arguments);\n\n        return fun.apply(this, reversed);\n      };\n    },\n    // Takes a method-style function (one which uses `this`) and pushes\n    // `this` into the argument list. The returned function uses its first\n    // argument as the receiver/context of the original function, and the rest\n    // of the arguments are used as the original's entire argument list.\n    functionalize: function functionalize(method) {\n      return function (ctx\n      /*, args */\n      ) {\n        return method.apply(ctx, _.rest(arguments));\n      };\n    },\n    // Takes a function and pulls the first argument out of the argument\n    // list and into `this` position. The returned function calls the original\n    // with its receiver (`this`) prepending the argument list. The original\n    // is called with a receiver of `null`.\n    methodize: function methodize(func) {\n      return function ()\n      /* args */\n      {\n        return func.apply(null, _.cons(this, arguments));\n      };\n    },\n    k: _.always,\n    t: _.pipeline\n  });\n\n  _.unsplatr = _.unsplat; // map the arguments of a function, takes the mapping function\n  // first so it can be used as a combinator\n\n  _.mapArgsWith = curry2(_.flip(baseMapArgs)); // Returns function property of object by name, bound to object\n\n  _.bound = function (obj, fname) {\n    var fn = obj[fname];\n    if (!_.isFunction(fn)) throw new TypeError(\"Expected property to be a function\");\n    return _.bind(fn, obj);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}