{"ast":null,"code":"module.exports = function (_) {\n  // Helpers\n  // -------\n  // An internal object that can be returned from a visitor function to\n  // prevent a top-down walk from walking subtrees of a node.\n  var stopRecursion = {}; // An internal object that can be returned from a visitor function to\n  // cause the walk to immediately stop.\n\n  var stopWalk = {};\n  var notTreeError = 'Not a tree: same object found in two different branches'; // Implements the default traversal strategy: if `obj` is a DOM node, walk\n  // its DOM children; otherwise, walk all the objects it references.\n\n  function defaultTraversal(obj) {\n    return _.isElement(obj) ? obj.children : obj;\n  } // Walk the tree recursively beginning with `root`, calling `beforeFunc`\n  // before visiting an objects descendents, and `afterFunc` afterwards.\n  // If `collectResults` is true, the last argument to `afterFunc` will be a\n  // collection of the results of walking the node's subtrees.\n\n\n  function walkImpl(root, traversalStrategy, beforeFunc, afterFunc, context, collectResults) {\n    var visited = [];\n    return function _walk(value, key, parent) {\n      // Keep track of objects that have been visited, and throw an exception\n      // when trying to visit the same object twice.\n      if (_.isObject(value)) {\n        if (visited.indexOf(value) >= 0) throw new TypeError(notTreeError);\n        visited.push(value);\n      }\n\n      if (beforeFunc) {\n        var result = beforeFunc.call(context, value, key, parent);\n        if (result === stopWalk) return stopWalk;\n        if (result === stopRecursion) return;\n      }\n\n      var subResults;\n      var target = traversalStrategy(value);\n\n      if (_.isObject(target) && !_.isEmpty(target)) {\n        // If collecting results from subtrees, collect them in the same shape\n        // as the parent node.\n        if (collectResults) subResults = _.isArray(value) ? [] : {};\n\n        var stop = _.any(target, function (obj, key) {\n          var result = _walk(obj, key, value);\n\n          if (result === stopWalk) return true;\n          if (subResults) subResults[key] = result;\n        });\n\n        if (stop) return stopWalk;\n      }\n\n      if (afterFunc) return afterFunc.call(context, value, key, parent, subResults);\n    }(root);\n  } // Internal helper providing the implementation for `pluck` and `pluckRec`.\n\n\n  function _pluck(obj, propertyName, recursive) {\n    var results = [];\n    this.preorder(obj, function (value, key) {\n      if (!recursive && key == propertyName) return stopRecursion;\n      if (_.has(value, propertyName)) results[results.length] = value[propertyName];\n    });\n    return results;\n  }\n\n  var exports = {\n    // Performs a preorder traversal of `obj` and returns the first value\n    // which passes a truth test.\n    find: function find(obj, visitor, context) {\n      var result;\n      this.preorder(obj, function (value, key, parent) {\n        if (visitor.call(context, value, key, parent)) {\n          result = value;\n          return stopWalk;\n        }\n      }, context);\n      return result;\n    },\n    // Recursively traverses `obj` and returns all the elements that pass a\n    // truth test. `strategy` is the traversal function to use, e.g. `preorder`\n    // or `postorder`.\n    filter: function filter(obj, strategy, visitor, context) {\n      var results = [];\n      if (obj == null) return results;\n      strategy(obj, function (value, key, parent) {\n        if (visitor.call(context, value, key, parent)) results.push(value);\n      }, null, this._traversalStrategy);\n      return results;\n    },\n    // Recursively traverses `obj` and returns all the elements for which a\n    // truth test fails.\n    reject: function reject(obj, strategy, visitor, context) {\n      return this.filter(obj, strategy, function (value, key, parent) {\n        return !visitor.call(context, value, key, parent);\n      });\n    },\n    // Produces a new array of values by recursively traversing `obj` and\n    // mapping each value through the transformation function `visitor`.\n    // `strategy` is the traversal function to use, e.g. `preorder` or\n    // `postorder`.\n    map: function map(obj, strategy, visitor, context) {\n      var results = [];\n      strategy(obj, function (value, key, parent) {\n        results[results.length] = visitor.call(context, value, key, parent);\n      }, null, this._traversalStrategy);\n      return results;\n    },\n    // Return the value of properties named `propertyName` reachable from the\n    // tree rooted at `obj`. Results are not recursively searched; use\n    // `pluckRec` for that.\n    pluck: function pluck(obj, propertyName) {\n      return _pluck.call(this, obj, propertyName, false);\n    },\n    // Version of `pluck` which recursively searches results for nested objects\n    // with a property named `propertyName`.\n    pluckRec: function pluckRec(obj, propertyName) {\n      return _pluck.call(this, obj, propertyName, true);\n    },\n    // Recursively traverses `obj` in a depth-first fashion, invoking the\n    // `visitor` function for each object only after traversing its children.\n    // `traversalStrategy` is intended for internal callers, and is not part\n    // of the public API.\n    postorder: function postorder(obj, visitor, context, traversalStrategy) {\n      traversalStrategy = traversalStrategy || this._traversalStrategy;\n      walkImpl(obj, traversalStrategy, null, visitor, context);\n    },\n    // Recursively traverses `obj` in a depth-first fashion, invoking the\n    // `visitor` function for each object before traversing its children.\n    // `traversalStrategy` is intended for internal callers, and is not part\n    // of the public API.\n    preorder: function preorder(obj, visitor, context, traversalStrategy) {\n      traversalStrategy = traversalStrategy || this._traversalStrategy;\n      walkImpl(obj, traversalStrategy, visitor, null, context);\n    },\n    // Builds up a single value by doing a post-order traversal of `obj` and\n    // calling the `visitor` function on each object in the tree. For leaf\n    // objects, the `memo` argument to `visitor` is the value of the `leafMemo`\n    // argument to `reduce`. For non-leaf objects, `memo` is a collection of\n    // the results of calling `reduce` on the object's children.\n    reduce: function reduce(obj, visitor, leafMemo, context) {\n      var reducer = function reducer(value, key, parent, subResults) {\n        return visitor(subResults || leafMemo, value, key, parent);\n      };\n\n      return walkImpl(obj, this._traversalStrategy, null, reducer, context, true);\n    }\n  }; // Set up aliases to match those in lodash.js.\n\n  exports.collect = exports.map;\n  exports.detect = exports.find;\n  exports.select = exports.filter; // Returns an object containing the walk functions. If `traversalStrategy`\n  // is specified, it is a function determining how objects should be\n  // traversed. Given an object, it returns the object to be recursively\n  // walked. The default strategy is equivalent to `_.identity` for regular\n  // objects, and for DOM nodes it returns the node's DOM children.\n\n  function walk(traversalStrategy) {\n    var walker = _.clone(exports); // Bind all of the public functions in the walker to itself. This allows\n    // the traversal strategy to be dynamically scoped.\n\n\n    _.bindAll.apply(null, [walker].concat(_.keys(walker)));\n\n    walker._traversalStrategy = traversalStrategy || defaultTraversal;\n    return walker;\n  } // Use `_.walk` as a namespace to hold versions of the walk functions which\n  // use the default traversal strategy.\n\n\n  _.extend(walk, walk());\n\n  _.mixin({\n    walk: walk\n  });\n};","map":null,"metadata":{},"sourceType":"script"}