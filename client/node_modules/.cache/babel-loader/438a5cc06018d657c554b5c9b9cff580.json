{"ast":null,"code":"/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nimport * as React from 'react';\nimport { invariant } from '@formatjs/intl-utils';\nimport { assignUniqueKeysToParts } from '../utils';\nimport IntlMessageFormat, { isFormatXMLElementFn } from 'intl-messageformat';\nimport { MissingTranslationError, MessageFormatError } from '../error';\n\nfunction setTimeZoneInOptions(opts, timeZone) {\n  return Object.keys(opts).reduce(function (all, k) {\n    all[k] = __assign({\n      timeZone: timeZone\n    }, opts[k]);\n    return all;\n  }, {});\n}\n\nfunction deepMergeOptions(opts1, opts2) {\n  var keys = Object.keys(__assign(__assign({}, opts1), opts2));\n  return keys.reduce(function (all, k) {\n    all[k] = __assign(__assign({}, opts1[k] || {}), opts2[k] || {});\n    return all;\n  }, {});\n}\n\nfunction deepMergeFormatsAndSetTimeZone(f1, timeZone) {\n  if (!timeZone) {\n    return f1;\n  }\n\n  var mfFormats = IntlMessageFormat.formats;\n  return __assign(__assign(__assign({}, mfFormats), f1), {\n    date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)),\n    time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone))\n  });\n}\n\nexport function assignUniqueKeysToFormatXMLElementFnArgument(values) {\n  return Object.keys(values).reduce(function (acc, k) {\n    var v = values[k];\n    acc[k] = isFormatXMLElementFn(v) ? assignUniqueKeysToParts(v) : v;\n    return acc;\n  }, {});\n}\n\nfunction prepareIntlMessageFormatHtmlOutput(chunks, shouldWrap) {\n  return Array.isArray(chunks) && shouldWrap ? React.createElement.apply(React, __spreadArrays([React.Fragment, null], chunks)) : chunks;\n}\n\nexport function formatMessage(_a, state, messageDescriptor, values) {\n  var locale = _a.locale,\n      formats = _a.formats,\n      messages = _a.messages,\n      defaultLocale = _a.defaultLocale,\n      defaultFormats = _a.defaultFormats,\n      onError = _a.onError,\n      timeZone = _a.timeZone,\n      wrapRichTextChunksInFragment = _a.wrapRichTextChunksInFragment;\n\n  if (messageDescriptor === void 0) {\n    messageDescriptor = {\n      id: ''\n    };\n  }\n\n  var id = messageDescriptor.id,\n      defaultMessage = messageDescriptor.defaultMessage; // `id` is a required field of a Message Descriptor.\n\n  invariant(!!id, '[React Intl] An `id` must be provided to format a message.');\n  var message = messages && messages[String(id)]; // IMPORTANT: Hot path straight lookup for performance\n\n  if (!values && message && typeof message === 'string') {\n    return message.replace(/'\\{(.*?)\\}'/gi, \"{$1}\");\n  }\n\n  var patchedValues = values && assignUniqueKeysToFormatXMLElementFnArgument(values);\n  formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);\n  defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);\n\n  if (!message) {\n    if (!defaultMessage || locale && locale.toLowerCase() !== defaultLocale.toLowerCase()) {\n      // This prevents warnings from littering the console in development\n      // when no `messages` are passed into the <IntlProvider> for the\n      // default locale.\n      onError(new MissingTranslationError(messageDescriptor, locale));\n    }\n\n    if (defaultMessage) {\n      try {\n        var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats);\n        return prepareIntlMessageFormatHtmlOutput(formatter.format(patchedValues), wrapRichTextChunksInFragment);\n      } catch (e) {\n        onError(new MessageFormatError(\"Error formatting default message for: \\\"\" + id + \"\\\", rendering default message verbatim\", locale, messageDescriptor, e));\n        return defaultMessage;\n      }\n    }\n\n    return id;\n  } // We have the translated message\n\n\n  try {\n    var formatter = state.getMessageFormat(message, locale, formats, {\n      formatters: state\n    });\n    return prepareIntlMessageFormatHtmlOutput(formatter.format(patchedValues), wrapRichTextChunksInFragment);\n  } catch (e) {\n    onError(new MessageFormatError(\"Error formatting message: \\\"\" + id + \"\\\", using \" + (defaultMessage ? 'default message' : 'id') + \" as fallback.\", locale, messageDescriptor, e));\n  }\n\n  if (defaultMessage) {\n    try {\n      var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats);\n      return prepareIntlMessageFormatHtmlOutput(formatter.format(patchedValues), wrapRichTextChunksInFragment);\n    } catch (e) {\n      onError(new MessageFormatError(\"Error formatting the default message for: \\\"\" + id + \"\\\", rendering message verbatim\", locale, messageDescriptor, e));\n    }\n  }\n\n  return message || defaultMessage || id;\n}","map":null,"metadata":{},"sourceType":"module"}