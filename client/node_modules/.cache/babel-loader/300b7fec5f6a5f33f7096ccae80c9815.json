{"ast":null,"code":"import Sortable from 'sortablejs';\nexport { MultiDrag, default as Sortable, Swap } from 'sortablejs';\nimport classNames from 'classnames';\nimport { createElement, Children, cloneElement, createRef, Component } from 'react';\nimport invariant from 'tiny-invariant';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\n/**\r\n * Removes the `node` from the DOM\r\n * @param node\r\n */\n\n\nfunction removeNode(node) {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\n/**\r\n * Inserts the `newChild` node at the given index in a parent\r\n * @param parent The parent HTML Element.\r\n * @param newChild A HTML eement to add as a child of the parent.\r\n * @param index index of the parent to place the new child in.\r\n */\n\n\nfunction insertNodeAt(parent, newChild, index) {\n  var refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\n\nfunction removeNodes(customs) {\n  customs.forEach(function (curr) {\n    return removeNode(curr.element);\n  });\n}\n\nfunction insertNodes(customs) {\n  customs.forEach(function (curr) {\n    insertNodeAt(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\n\nfunction createCustoms(evt, list) {\n  var mode = getMode(evt);\n  var parentElement = {\n    parentElement: evt.from\n  };\n  var custom = [];\n\n  switch (mode) {\n    case \"normal\":\n      var item = {\n        element: evt.item,\n        newIndex: evt.newIndex,\n        oldIndex: evt.oldIndex,\n        parentElement: evt.from\n      };\n      custom = [item];\n      break;\n\n    case \"swap\":\n      var drag = _assign({\n        element: evt.item,\n        oldIndex: evt.oldIndex,\n        newIndex: evt.newIndex\n      }, parentElement);\n\n      var swap = _assign({\n        element: evt.swapItem,\n        oldIndex: evt.newIndex,\n        newIndex: evt.oldIndex\n      }, parentElement);\n\n      custom = [drag, swap];\n      break;\n\n    case \"multidrag\":\n      custom = evt.oldIndicies.map(function (curr, index) {\n        return _assign({\n          element: curr.multiDragElement,\n          oldIndex: curr.index,\n          newIndex: evt.newIndicies[index].index\n        }, parentElement);\n      });\n      break;\n  }\n\n  var customs = createNormalized(custom, list);\n  return customs;\n}\n/** moves items form old index to new index without breaking anything ideally. */\n\n\nfunction handleStateChanges(normalized, list) {\n  var a = handleStateRemove(normalized, list);\n  var b = handleStateAdd(normalized, a);\n  return b;\n}\n\nfunction handleStateRemove(normalized, list) {\n  var newList = __spread(list);\n\n  normalized.concat().reverse().forEach(function (curr) {\n    return newList.splice(curr.oldIndex, 1);\n  });\n  return newList;\n}\n\nfunction handleStateAdd(normalized, list) {\n  var newList = __spread(list);\n\n  normalized.forEach(function (curr) {\n    return newList.splice(curr.newIndex, 0, curr.item);\n  });\n  return newList;\n}\n\nfunction getMode(evt) {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\n\nfunction createNormalized(inputs, list) {\n  var normalized = inputs.map(function (curr) {\n    return _assign(_assign({}, curr), {\n      item: list[curr.oldIndex]\n    });\n  }).sort(function (a, b) {\n    return a.oldIndex - b.oldIndex;\n  });\n  return normalized;\n}\n/**\r\n * Removes the following group of properties from `props`,\r\n * leaving only `Sortable.Options` without any `on` methods.\r\n * @param props `ReactSortable.Props`\r\n */\n\n\nfunction destructurePropsForOptions(props) {\n  var // react sortable props\n  list = props.list,\n      setList = props.setList,\n      children = props.children,\n      tag = props.tag,\n      style = props.style,\n      className = props.className,\n      clone = props.clone,\n      // sortable options that have methods we want to overwrite\n  onAdd = props.onAdd,\n      onChange = props.onChange,\n      onChoose = props.onChoose,\n      onClone = props.onClone,\n      onEnd = props.onEnd,\n      onFilter = props.onFilter,\n      onRemove = props.onRemove,\n      onSort = props.onSort,\n      onStart = props.onStart,\n      onUnchoose = props.onUnchoose,\n      onUpdate = props.onUpdate,\n      onMove = props.onMove,\n      onSpill = props.onSpill,\n      onSelect = props.onSelect,\n      onDeselect = props.onDeselect,\n      options = __rest(props, [\"list\", \"setList\", \"children\", \"tag\", \"style\", \"className\", \"clone\", \"onAdd\", \"onChange\", \"onChoose\", \"onClone\", \"onEnd\", \"onFilter\", \"onRemove\", \"onSort\", \"onStart\", \"onUnchoose\", \"onUpdate\", \"onMove\", \"onSpill\", \"onSelect\", \"onDeselect\"]);\n\n  return options;\n}\n/** Holds a global reference for which react element is being dragged */\n// @todo - use context to manage this. How does one use 2 different providers?\n\n\nvar store = {\n  dragging: null\n};\n\nvar ReactSortable =\n/** @class */\nfunction (_super) {\n  __extends(ReactSortable, _super);\n\n  function ReactSortable(props) {\n    var _this = _super.call(this, props) || this; // @todo forward ref this component\n\n\n    _this.ref = createRef(); // make all state false because we can't change sortable unless a mouse gesture is made.\n\n    var newList = __spread(props.list).map(function (item) {\n      return _assign(_assign({}, item), {\n        chosen: false,\n        selected: false\n      });\n    });\n\n    props.setList(newList, _this.sortable, store);\n    invariant( //@ts-ignore\n    !props.plugins, \"\\nPlugins prop is no longer supported.\\nInstead, mount it with \\\"Sortable.mount(new MultiDrag())\\\"\\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\\n      \");\n    return _this;\n  }\n\n  ReactSortable.prototype.componentDidMount = function () {\n    if (this.ref.current === null) return;\n    var newOptions = this.makeOptions();\n    Sortable.create(this.ref.current, newOptions);\n  };\n\n  ReactSortable.prototype.render = function () {\n    var _a = this.props,\n        tag = _a.tag,\n        style = _a.style,\n        className = _a.className,\n        id = _a.id;\n    var classicProps = {\n      style: style,\n      className: className,\n      id: id\n    }; // if no tag, default to a `div` element.\n\n    var newTag = !tag || tag === null ? \"div\" : tag;\n    return createElement(newTag, _assign({\n      // @todo - find a way (perhaps with the callback) to allow AntD components to work\n      ref: this.ref\n    }, classicProps), this.getChildren());\n  };\n\n  ReactSortable.prototype.getChildren = function () {\n    var _a = this.props,\n        children = _a.children,\n        dataIdAttr = _a.dataIdAttr,\n        _b = _a.selectedClass,\n        selectedClass = _b === void 0 ? \"sortable-selected\" : _b,\n        _c = _a.chosenClass,\n        chosenClass = _c === void 0 ? \"sortable-chosen\" : _c,\n        _d = _a.dragClass,\n        _e = _a.fallbackClass,\n        _f = _a.ghostClass,\n        _g = _a.swapClass,\n        _h = _a.filter,\n        filter = _h === void 0 ? \"sortable-filter\" : _h,\n        list = _a.list; // if no children, don't do anything.\n\n    if (!children || children == null) return null;\n    var dataid = dataIdAttr || \"data-id\";\n    return Children.map(children, function (child, index) {\n      var _a, _b, _c;\n\n      var item = list[index];\n      var prevClassName = child.props.className; // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n\n      var filtered = typeof filter === \"string\" && (_a = {}, _a[filter.replace(\".\", \"\")] = !!item.filtered, _a);\n      var className = classNames(prevClassName, _assign((_b = {}, _b[selectedClass] = item.selected, _b[chosenClass] = item.chosen, _b), filtered // [dragClass]: true,\n      // [fallbackClass]: true,\n      // [ghostClass]: true,\n      // [swapClass]: true\n      ));\n      return cloneElement(child, (_c = {}, _c[dataid] = child.key, _c.className = className, _c));\n    });\n  };\n\n  Object.defineProperty(ReactSortable.prototype, \"sortable\", {\n    /** Appends the `sortable` property to this component */\n    get: function get() {\n      var el = this.ref.current;\n      if (el === null) return null;\n      var key = Object.keys(el).find(function (k) {\n        return k.includes(\"Sortable\");\n      });\n      if (!key) return null; //@ts-ignore - I know what I'm doing.\n\n      return el[key];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n\n  ReactSortable.prototype.makeOptions = function () {\n    var _this = this;\n\n    var DOMHandlers = [\"onAdd\", \"onChoose\", \"onDeselect\", \"onEnd\", \"onRemove\", \"onSelect\", \"onSpill\", \"onStart\", \"onUnchoose\", \"onUpdate\"];\n    var NonDOMHandlers = [\"onChange\", \"onClone\", \"onFilter\", \"onSort\"];\n    var newOptions = destructurePropsForOptions(this.props);\n    DOMHandlers.forEach(function (name) {\n      return newOptions[name] = _this.prepareOnHandlerPropAndDOM(name);\n    });\n    NonDOMHandlers.forEach(function (name) {\n      return newOptions[name] = _this.prepareOnHandlerProp(name);\n    });\n    /** onMove has 2 arguments and needs to be handled seperately. */\n\n    var onMove = function onMove(evt, originalEvt) {\n      var onMove = _this.props.onMove;\n      var defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      var result = onMove(evt, originalEvt, _this.sortable, store);\n      if (typeof result === 'undefined') return false;\n      return result;\n    };\n\n    return _assign(_assign({}, newOptions), {\n      onMove: onMove\n    });\n  };\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n\n\n  ReactSortable.prototype.prepareOnHandlerPropAndDOM = function (evtName) {\n    var _this = this;\n\n    return function (evt) {\n      // call the component prop\n      _this.callOnHandlerProp(evt, evtName); // calls state change\n      //@ts-ignore - until @types multidrag item is in\n\n\n      _this[evtName](evt);\n    };\n  };\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n\n\n  ReactSortable.prototype.prepareOnHandlerProp = function (evtName) {\n    var _this = this;\n\n    return function (evt) {\n      // call the component prop\n      _this.callOnHandlerProp(evt, evtName);\n    };\n  };\n  /** Calls the `props.on[Handler]` function */\n\n\n  ReactSortable.prototype.callOnHandlerProp = function (evt, evtName) {\n    var propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, store);\n  }; // SORTABLE DOM HANDLING\n\n\n  ReactSortable.prototype.onAdd = function (evt) {\n    var _a = this.props,\n        list = _a.list,\n        setList = _a.setList;\n\n    var otherList = __spread(store.dragging.props.list);\n\n    var customs = createCustoms(evt, otherList);\n    removeNodes(customs);\n    var newList = handleStateAdd(customs, list);\n    setList(newList, this.sortable, store);\n  };\n\n  ReactSortable.prototype.onRemove = function (evt) {\n    var _this = this;\n\n    var _a = this.props,\n        list = _a.list,\n        setList = _a.setList;\n    var mode = getMode(evt);\n    var customs = createCustoms(evt, list);\n    insertNodes(customs);\n\n    var newList = __spread(list); // remove state if not in clone mode. otherwise, keep.\n\n\n    if (evt.pullMode !== \"clone\") newList = handleStateRemove(customs, newList); // if clone, it doesn't really remove. instead it clones in place.\n    // @todo -\n    else {\n        // switch used to get the clone\n        var customClones = customs;\n\n        switch (mode) {\n          case \"multidrag\":\n            customClones = customs.map(function (item, index) {\n              return _assign(_assign({}, item), {\n                element: evt.clones[index]\n              });\n            });\n            break;\n\n          case \"normal\":\n            customClones = customs.map(function (item, index) {\n              return _assign(_assign({}, item), {\n                element: evt.clone\n              });\n            });\n            break;\n\n          case \"swap\":\n          default:\n            {\n              invariant(true, \"mode \\\"\" + mode + \"\\\" cannot clone. Please remove \\\"props.clone\\\" from <ReactSortable/> when using the \\\"\" + mode + \"\\\" plugin\");\n            }\n        }\n\n        removeNodes(customClones); // replace selected items with cloned items\n\n        customs.forEach(function (curr) {\n          var index = curr.oldIndex;\n\n          var newItem = _this.props.clone(curr.item, evt);\n\n          newList.splice(index, 1, newItem);\n        });\n      } // remove item.selected from list\n\n    newList = newList.map(function (item) {\n      return _assign(_assign({}, item), {\n        selected: false\n      });\n    });\n    setList(newList, this.sortable, store);\n  };\n\n  ReactSortable.prototype.onUpdate = function (evt) {\n    var _a = this.props,\n        list = _a.list,\n        setList = _a.setList;\n    var customs = createCustoms(evt, list);\n    removeNodes(customs);\n    insertNodes(customs);\n    var newList = handleStateChanges(customs, list);\n    return setList(newList, this.sortable, store);\n  };\n\n  ReactSortable.prototype.onStart = function (evt) {\n    store.dragging = this;\n  };\n\n  ReactSortable.prototype.onEnd = function (evt) {\n    store.dragging = null;\n  };\n\n  ReactSortable.prototype.onChoose = function (evt) {\n    var _a = this.props,\n        list = _a.list,\n        setList = _a.setList;\n\n    var newList = __spread(list);\n\n    newList[evt.oldIndex].chosen = true;\n    setList(newList, this.sortable, store);\n  };\n\n  ReactSortable.prototype.onUnchoose = function (evt) {\n    var _a = this.props,\n        list = _a.list,\n        setList = _a.setList;\n\n    var newList = __spread(list);\n\n    newList[evt.oldIndex].chosen = false;\n    setList(newList, this.sortable, store);\n  };\n\n  ReactSortable.prototype.onSpill = function (evt) {\n    var _a = this.props,\n        removeOnSpill = _a.removeOnSpill,\n        revertOnSpill = _a.revertOnSpill;\n    if (removeOnSpill && !revertOnSpill) removeNode(evt.item);\n  };\n\n  ReactSortable.prototype.onSelect = function (evt) {\n    var _a = this.props,\n        list = _a.list,\n        setList = _a.setList;\n\n    var newList = __spread(list).map(function (item) {\n      return _assign(_assign({}, item), {\n        selected: false\n      });\n    });\n\n    evt.newIndicies.forEach(function (curr) {\n      var index = curr.index;\n\n      if (index === -1) {\n        console.log(\"\\\"\" + evt.type + \"\\\" had indice of \\\"\" + curr.index + \"\\\", which is probably -1 and doesn't usually happen here.\");\n        console.log(evt);\n        return;\n      }\n\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  };\n\n  ReactSortable.prototype.onDeselect = function (evt) {\n    var _a = this.props,\n        list = _a.list,\n        setList = _a.setList;\n\n    var newList = __spread(list).map(function (item) {\n      return _assign(_assign({}, item), {\n        selected: false\n      });\n    });\n\n    evt.newIndicies.forEach(function (curr) {\n      var index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  };\n\n  ReactSortable.defaultProps = {\n    clone: function clone(item) {\n      return item;\n    }\n  };\n  return ReactSortable;\n}(Component);\n\nexport { ReactSortable };","map":null,"metadata":{},"sourceType":"module"}