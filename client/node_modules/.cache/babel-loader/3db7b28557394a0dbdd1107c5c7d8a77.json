{"ast":null,"code":"module.exports = function (_) {\n  // Create quick reference variables for speed access to core prototypes.\n  var slice = Array.prototype.slice,\n      concat = Array.prototype.concat;\n\n  var existy = function existy(x) {\n    return x != null;\n  };\n\n  var truthy = function truthy(x) {\n    return x !== false && existy(x);\n  };\n\n  var isSeq = function isSeq(x) {\n    return _.isArray(x) || _.isArguments(x);\n  };\n\n  function nths(array, indices) {\n    if (array == null) return void 0;\n    if (isSeq(indices)) return _(indices).map(function (i) {\n      return array[i];\n    }).valueOf();else return nths(array, slice.call(arguments, 1));\n  } // Mixing in the array selectors\n  // ----------------------------\n\n\n  _.mixin({\n    // Returns the second element of an array. Passing **n** will return all but\n    // the first of the head N values in the array.  The **guard** check allows it\n    // to work with `_.map`.\n    second: function second(array, n, guard) {\n      if (array == null) return void 0;\n      return n != null && !guard ? slice.call(array, 1, n) : array[1];\n    },\n    // Returns the third element of an array. Passing **n** will return all but\n    // the first two of the head N values in the array.  The **guard** check allows it\n    // to work with `_.map`.\n    third: function third(array, n, guard) {\n      if (array == null) return void 0;\n      return n != null && !guard ? slice.call(array, 2, n) : array[2];\n    },\n    // A function to get at an index into an array\n    nth: function nth(array, index, guard) {\n      if (index != null && !guard) return array[index];\n    },\n    // A function to get values via indices into an array\n    nths: nths,\n    valuesAt: nths,\n    // A function to get at \"truthily\" indexed values\n    // bin refers to \"binary\" nature of true/false values in binIndices\n    // but can also be thought of as putting array values into either \"take\" or \"don't\" bins\n    binPick: function binPick(array, binIndices) {\n      if (array == null) return void 0;\n      if (isSeq(binIndices)) return _.nths(array, _.range(binIndices.length).filter(function (i) {\n        return binIndices[i];\n      }));else return binPick(array, slice.call(arguments, 1));\n    },\n    // Returns an array with two internal arrays built from\n    // taking an original array and spliting it at the index\n    // where a given function goes falsey.\n    splitWith: function splitWith(array, pred) {\n      return [_.takeWhile(array, pred), _.dropWhile(array, pred)];\n    },\n    // Takes an array and partitions it as the given predicate changes\n    // truth sense.\n    partitionBy: function partitionBy(array, fun) {\n      if (_.isEmpty(array) || !existy(array)) return [];\n\n      var fst = _.first(array);\n\n      var fstVal = fun(fst);\n      var run = concat.call([fst], _.takeWhile(_.rest(array), function (e) {\n        return _.isEqual(fstVal, fun(e));\n      }));\n      return concat.call([run], _.partitionBy(_.drop(array, _.size(run)), fun));\n    },\n    // Returns the 'best' value in an array based on the result of a\n    // given function.\n    best: function best(array, fun) {\n      return _.reduce(array, function (x, y) {\n        return fun(x, y) ? x : y;\n      });\n    },\n    // Returns an array of existy results of a function over an source array.\n    keep: function keep(array, fun) {\n      if (!isSeq(array)) throw new TypeError(\"expected an array as the first argument\");\n      return _.filter(_.map(array, function (e) {\n        return fun(e);\n      }), existy);\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}