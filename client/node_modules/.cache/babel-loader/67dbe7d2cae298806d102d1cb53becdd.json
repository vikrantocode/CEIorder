{"ast":null,"code":"module.exports = function (_) {\n  // Create quick reference variables for speed access to core prototypes.\n  var slice = Array.prototype.slice,\n      concat = Array.prototype.concat,\n      sort = Array.prototype.sort;\n\n  var existy = function existy(x) {\n    return x != null;\n  }; // Mixing in the array builders\n  // ----------------------------\n\n\n  _.mixin({\n    // Concatenates one or more arrays given as arguments.  If given objects and\n    // scalars as arguments `cat` will plop them down in place in the result\n    // array.  If given an `arguments` object, `cat` will treat it like an array\n    // and concatenate it likewise.\n    cat: function cat() {\n      return _.reduce(arguments, function (acc, elem) {\n        if (_.isArguments(elem)) {\n          return concat.call(acc, slice.call(elem));\n        } else {\n          return concat.call(acc, elem);\n        }\n      }, []);\n    },\n    // 'Constructs' an array by putting an element at its front\n    cons: function cons(head, tail) {\n      return _.cat([head], tail);\n    },\n    // Takes an array and chunks it some number of times into\n    // sub-arrays of size n.  Allows and optional padding array as\n    // the third argument to fill in the tail chunk when n is\n    // not sufficient to build chunks of the same size.\n    chunkContrib: function chunkContrib(array, n, pad) {\n      var args = arguments;\n\n      var p = function p(array) {\n        if (array == null) return [];\n\n        var part = _.take(array, n);\n\n        if (n === _.size(part)) {\n          return _.cons(part, p(_.drop(array, n)));\n        } else if (args.length === 3) {\n          pad = _.isArray(pad) ? pad : _.repeatContrib(n, pad);\n          return [_.take(_.cat(part, pad), n)];\n        } else {\n          return [];\n        }\n      };\n\n      return p(array);\n    },\n    // Takes an array and chunks it some number of times into\n    // sub-arrays of size n.  If the array given cannot fill the size\n    // needs of the final chunk then a smaller chunk is used\n    // for the last.\n    chunkAll: function chunkAll(array, n, step) {\n      step = step != null ? step : n;\n\n      var p = function p(array, n, step) {\n        if (_.isEmpty(array)) return [];\n        return _.cons(_.take(array, n), p(_.drop(array, step), n, step));\n      };\n\n      return p(array, n, step);\n    },\n    // Maps a function over an array and concatenates all of the results.\n    mapcat: function mapcat(array, fun) {\n      return _.cat.apply(null, _.map(array, fun));\n    },\n    // Returns an array with some item between each element\n    // of a given array.\n    interpose: function interpose(array, inter) {\n      if (!_.isArray(array)) throw new TypeError();\n\n      var sz = _.size(array);\n\n      if (sz === 0) return array;\n      if (sz === 1) return array;\n      return slice.call(_.mapcat(array, function (elem) {\n        return _.cons(elem, [inter]);\n      }), 0, -1);\n    },\n    // Weaves two or more arrays together\n    weave: function weave()\n    /* args */\n    {\n      if (!_.some(arguments)) return [];\n      if (arguments.length == 1) return arguments[0];\n      return _.filter(_.flatten(_.zip.apply(null, arguments), false), function (elem) {\n        return elem != null;\n      });\n    },\n    interleave: _.weave,\n    // Returns an array of a value repeated a certain number of\n    // times.\n    repeatContrib: function repeatContrib(t, elem) {\n      return _.times(t, function () {\n        return elem;\n      });\n    },\n    // Returns an array built from the contents of a given array repeated\n    // a certain number of times.\n    cycle: function cycle(t, elems) {\n      return _.flatten(_.times(t, function () {\n        return elems;\n      }), true);\n    },\n    // Returns an array with two internal arrays built from\n    // taking an original array and spliting it at an index.\n    splitAt: function splitAt(array, index) {\n      return [_.take(array, index), _.drop(array, index)];\n    },\n    // Call a function recursively f(f(f(args))) until a second\n    // given function goes falsey.  Expects a seed value to start.\n    iterateUntil: function iterateUntil(doit, checkit, seed) {\n      var ret = [];\n      var result = doit(seed);\n\n      while (checkit(result)) {\n        ret.push(result);\n        result = doit(result);\n      }\n\n      return ret;\n    },\n    // Takes every nth item from an array, returning an array of\n    // the results.\n    takeSkipping: function takeSkipping(array, n) {\n      var ret = [];\n\n      var sz = _.size(array);\n\n      if (n <= 0) return [];\n      if (n === 1) return array;\n\n      for (var index = 0; index < sz; index += n) {\n        ret.push(array[index]);\n      }\n\n      return ret;\n    },\n    // Returns an array of each intermediate stage of a call to\n    // a `reduce`-like function.\n    reductions: function reductions(array, fun, init) {\n      var ret = [];\n      var acc = init;\n\n      _.each(array, function (v, k) {\n        acc = fun(acc, array[k]);\n        ret.push(acc);\n      });\n\n      return ret;\n    },\n    // Runs its given function on the index of the elements rather than\n    // the elements themselves, keeping all of the truthy values in the end.\n    keepIndexed: function keepIndexed(array, pred) {\n      return _.filter(_.map(_.range(_.size(array)), function (i) {\n        return pred(i, array[i]);\n      }), existy);\n    },\n    // Accepts an array-like object (other than strings) as an argument and\n    // returns an array whose elements are in the reverse order. Unlike the\n    // built-in `Array.prototype.reverse` method, this does not mutate the\n    // original object. Note: attempting to use this method on a string will\n    // result in a `TypeError`, as it cannot properly reverse unicode strings.\n    reverseOrder: function reverseOrder(obj) {\n      if (typeof obj == 'string') throw new TypeError('Strings cannot be reversed by _.reverseOrder');\n      return slice.call(obj).reverse();\n    },\n    // Returns copy or array sorted according to arbitrary ordering\n    // order must be an array of values; defines the custom sort\n    // key must be one of: missing/null, a string, or a function;\n    collate: function collate(array, order, key) {\n      if (!_.isArray(array)) throw new TypeError(\"expected an array as the first argument\");\n      if (!_.isArray(order)) throw new TypeError(\"expected an array as the second argument\");\n      return sort.call(array, function (a, b) {\n        if (_.isFunction(key)) {\n          valA = key.call(a);\n          valB = key.call(b);\n        } else if (existy(key)) {\n          valA = a[key];\n          valB = b[key];\n        } else {\n          valA = a;\n          valB = b;\n        }\n\n        var rankA = _.indexOf(order, valA);\n\n        var rankB = _.indexOf(order, valB);\n\n        if (rankA === -1) return 1;\n        if (rankB === -1) return -1;\n        return rankA - rankB;\n      });\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}